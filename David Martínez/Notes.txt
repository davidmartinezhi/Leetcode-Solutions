Checar en C++:
    -Sets (En c++, usan el binary tree implementation, han de ser buenos para busqueda y ordenamiento)
    -Meter mi archivo sobre practicas de apuntadores, a este repositorio
    -"auto" en el uso de variables
        
*Puede ser utíl checar videos de gente resolviendo los problemas en el momento,
    De tal manera que pueda emular su approach a los problemas y saber identificarlos.
    
//repositorio
    -Agregar descripción en optimize and solve techniques 
    -Hacer digerible o poner ejemplos en solution_flow

*Escribir for loops de manera limpia
    x es el entero donde quiero que comience
    #define len(x) x.size()
    #define bf(i, x, n) for(int i = x; i < n; i++) //basic for (<)

    ahora for loop se escribe como 
    bf(i, 0, n){
        bf(j, 0, n){
            blablabla
        }
    }

//libro: http://englishonlineclub.com/pdf/Cracking%20the%20Coding%20Interview%20-%20189%20Programming%20Questions%20and%20Solutions%20(6th%20Edition)%20[EnglishOnlineClub.com].pdf
//Solution flow: pagina 62 del libro.

//Big O, resources
https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835



//Siento que strings y arrays en easy, van a ser una buena introcucción a la utilización de hashtables. update: es correcto

//He notado que las soluciones más eficientes, son muchas veces con manipulación de bits. No debo olvidarme en checar ese tema.
    -checar bitset y memset.

To-Do:

-Investigar cuando me puede ser utíl un algoritmo recursivo y como identificarlos. (Lo vere cuando llegue problemas de BST)
-Hacer, usando la metodologia del libro. Problemas Array easy: Single Number y Rotate Array.
-Luego investigar bits manipulation, ejemplo el ^= en c++ que es un XOR. Pendiente
    -Checar memset y bitset en manipulación de bits.
-Checar si podia resolver el problema de la entrevista con pointers o linkedlists.
-Poner ayuda rapida de como convertir letras de minusculas a mayusculas o como checar que algo es un numero o alphanumerico. (como en el problema easy/string/validPalindrome.cpp)
-Poner ayuda rapida para trabajar con limites cuando solo tenemos 32 bits. (Ya lo solucione, pero para que los demas no batallen)

Terminado
-Anotar problemas de mi entrevista para que los demas los tengan y lo puedan intentar. Terminado
-También checar el solution flow que viene en cracking the coding interview. Terminado.
-Anotar las "Optimize and Solve Techniques". Terminado
-Investigar unordered_map.
-Repasar Big O, en especial con memoria. Terminado
-Poner fuentes para estudiar big O y Link del libro. En el repositorio. terminado
-Lunes practicar set y maps en c++. O ver un video de alguién resolviendo el problema y ver con que lo resuelve el hashtable. terminado
-Debo terminar archivo estilo "cheatsheet" de optimize and solve technique. terminado
-Poner archivos con tecnicas de optimize and solve, profundizando en los temas. terminado
-Debo poner un super resumen en el archivo de optimize and solve technique. El folder solo tendra profundización y ejemplos
-Reverse integer y string to integer(atoi), checar como trabajar con limites. terminado

Reminder
-Contarles de los habitos de la gente altamente efectiva, "sharpen the saw".
    Esto para antes de introducirlos al solution flow y optimize and solve technique.
-Debo familiarizarme en trabajar con matrices.
-Sliding Window Technique: https://youtu.be/dQw4w9WgXcQ


Trees:
    -Los recorridos lo son todo.

    -Recorrido BFS es con Queue y DFS es con Recursividad, en Trees(arboles).
    BFS es para checar cada renglon en lo que llegas al final.

    BFS, checas cada renglon y luego si tiene nodos los agregas al queue. 
    El count es muy util para saber las operaciones que hacer y sobre que nodos hacerlo.

    DFS es para checar desde el final para arriba.
    Aquí se checa 1 o mas base cases, llamamos la función en subarbol iz, luego en subarbol der
    Unimos los resultados al regresar.
    
    Con recursividad también podría hacer el inorder, postorder y preorder-


La clave para los árboles es enteder las maneras de recorrerlo primero.
        -preorder
        -inorder
        -postorder
        -level by level (bfs)
        -dfs (recursividad)
    Esto es lo basic que todos deben de saber antes de siquiera comenzar a hacer los ejercicios al 100.


La clave en arrays y string:

    Usar Hashtables.

    Two pointer technique y sus derivados.
        -Uno al inicio y otro al final (-> <-)
        -Ambos enmedio y crecen hasta llegar a los extemos ( <- ->)
        -Pointer fijo y pointer iterativo
    
    Sliding Window Technique.
        -Fixed Window
        -Dynamic Window

Matrices:

    Usar vectores auxiliares que representan renglon y col.
    Familiareizarse con moverse fluido a traves de la matriz.
        Siempre recorres con 2 for loops, i y j. Depende como lo acomodes
        [i][j] estas recorriendo el renglon
        [j][i] estas recorriendo la columna 

Linked Lists:
    Slow & Fast pointers

Integers:
        Construir y deconstruir integers.
        Reverse an integer.

Chars:
        Hacer operaciones matematicas con los chars.

Investigar backtracking y bit manipulation